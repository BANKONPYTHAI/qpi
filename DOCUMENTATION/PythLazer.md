Pyth Lazer: Ultra-Low-Latency Price Oracle Deep Dive
Introduction
Pyth Lazer is a new ultra-low-latency price oracle service introduced by the Pyth Network in early 2025, designed to deliver extremely high-frequency market data updates for DeFi and trading applications
. It can provide price feeds with update intervals as short as 1 millisecond – roughly 400× faster than Pyth’s standard decentralized oracle feeds (now called Pyth Core)
. This breakthrough in speed is aimed at closing the performance gap between decentralized finance (DeFi) and traditional centralized exchanges, where every millisecond counts in high-frequency trading

. By minimizing data latency, Pyth Lazer enables on-chain protocols to react to market movements almost in real-time, which is critical for use cases like perpetual futures, algorithmic trading, and arbitrage that demand immediate price updates

. Pyth Lazer achieves its sub-second performance by making pragmatic trade-offs in decentralization, offering a permissioned, specialized service that prioritizes speed and precision over the full decentralization of Pyth’s regular feeds

. In essence, it’s an “ultra-fast” oracle option that complements Pyth Core – allowing developers to choose faster data when speed is paramount, or stick with the fully decentralized Pyth Core when maximum trustlessness is required

.
Pyth Lazer vs Pyth Core
Pyth Lazer was designed as a high-performance counterpart to the original Pyth Network price feeds (Pyth Core). The table below summarizes the key differences between Pyth Core and Pyth Lazer, highlighting how Lazer sacrifices some decentralization for significant gains in update speed and data richness:
Solution Type: Pyth Core is the stable, secure, fully decentralized price data source that any DeFi or TradFi application can integrate permissionlessly
pyth.network
. In contrast, Pyth Lazer is a specialized, permissioned service focused on ultra-low-latency market data for users that prioritize performance over maximum decentralization
. Pyth Core’s oracle network is open to all developers and governed by the community, whereas Lazer operates as a permissioned feed with a controlled integration process for select high-performance use cases (more on this below).
Update Frequency: Pyth Core publishes aggregate price updates roughly every 400 milliseconds on the Pyth Network appchain (Pythnet)
. This ~0.4s cadence is already fast by traditional oracle standards and includes safeguards like confidence intervals to mitigate risk (e.g. to reflect price uncertainty during volatile periods)
. Pyth Lazer, on the other hand, pushes the latency to the extreme – offering real-time streams as fast as 1ms, as well as fixed-rate update channels at 50ms and 200ms intervals, with other customizable frequencies available to suit different needs
. In essence, Lazer can refresh data hundreds of times faster than the normal Pyth feed, giving protocols the option to receive updates on a millisecond-by-millisecond basis if desired. This flexibility includes throttling or fixed schedules (e.g. a DApp could choose a 50ms feed if 1ms granularity is overkill)
.
Data Types: Pyth Core price feeds provide an aggregate price for each asset along with a confidence interval (a measure of uncertainty or price dispersion)
. This means a typical Pyth Core update might say, for example, “BTC/USD = $19,405.19 ± $9.907,” indicating the network’s aggregate price and the ± range of uncertainty
. Pyth Lazer offers a richer set of market data on each update. In addition to the aggregate price, Lazer feeds can include the best bid and ask prices, order book market depth, and other customizable data points (such as moving averages in the future)
. This gives DeFi protocols access to CEX-like granularity – they can observe not just a single price, but also the spread and liquidity, enabling more sophisticated trading strategies on-chain. (By providing this depth of data, Lazer helps decentralized platforms approach the level of insight that traders expect from traditional venues
pyth.network
.)
Fees: Both Pyth Core and Pyth Lazer use a pay-per-update model – an on-chain fee is charged for each signed price update delivered to a target chain. In Pyth’s pull-oracle design, a user (or a scheduling service) pays a small fee when fetching the latest price update into a smart contract transaction
. This fee model aligns incentives by having data consumers pay for the oracle usage. In practice, the fee for Pyth Lazer on Solana was initially set as low as 1 lamport (0.000000001 SOL) per update to encourage adoption
, but fees on other chains or for Core vs. Lazer may vary based on governance settings. The key point is that using Lazer doesn’t require a fundamentally different fee structure – you pay per update for the data, just as with Pyth Core (though the overall cost can differ due to the number and frequency of updates, as discussed next).
Update Costs & Efficiency: One major difference is the computational cost of verifying updates on-chain. Pyth Core price updates are delivered via Wormhole’s cross-chain messaging, which includes aggregated publisher signatures and a proof payload often over 1,000 bytes in size. Verifying these in a smart contract involves parsing multiple signatures and can be relatively heavy (though optimized given the security it provides). Pyth Lazer was engineered for lightness: its updates use roughly 100-byte proofs with a single simple signature to verify
linkedin.com
. This lightweight design drastically lowers the on-chain processing and bandwidth required to consume an update. For example, on Solana a Pyth Lazer transaction uses only ~15,000 compute units to verify and can bundle 20 price feeds in one transaction with minimal overhead
. By contrast, consuming the same number of Pyth Core feeds would involve larger proofs and higher compute time due to the more complex multi-signature verification. In short, Lazer trades the decentralized, multi-publisher verification of Core for a much slimmer update footprint, which saves on gas/compute costs and enables high-frequency updates without overwhelming the network
.
Integration Process: Integrating Pyth Core is an open and permissionless process – any developer or protocol can start using Pyth price feeds simply by reading the documentation and making on-chain calls, with no onboarding required
. Pyth’s mainnet is permissionless for consumers, meaning you don’t need special approval to pull prices into your smart contracts. By contrast, Pyth Lazer operates as a permissioned service: interested protocols must go through a custom integration (likely involving the Pyth team) to get access to Lazer’s data streams
. This is because Lazer runs on a specialized infrastructure and currently relies on a trusted data publisher (managed by Pyth contributors) to achieve its ultra-low latency. In essence, Pyth Lazer is offered to select partners or use cases that truly need millisecond-level data. It’s a “walled garden” approach compared to Pyth Core’s open garden. While any Web3 or Web2 project can permissionlessly tap into Pyth Core feeds, only permissioned clients can subscribe to Lazer feeds at this stage
. This ensures that Lazer’s resources remain focused on protocols that prioritize performance and are comfortable with a slightly more centralized setup for the sake of speed

Key Features and Capabilities of Pyth Lazer
Figure: Overview of Pyth Lazer's key features. Pyth Lazer is built to deliver ultra-fast price updates with minimal on-chain overhead, while providing rich market data and flexible integration options. It supports custom update frequencies (including real-time streams and fixed intervals) and is scalable to hundreds of feeds across multiple blockchains. This combination of features enables latency-sensitive DeFi protocols to obtain a CEX-like trading data experience on-chain, without having to run their own oracle infrastructure. Drawing on the above comparison, we can highlight the core features of Pyth Lazer that make it stand out as an oracle solution:
Ultra-Fast Update Frequencies: Pyth Lazer delivers market prices at unprecedented speeds. It offers a 1ms real-time channel for protocols that need to capture every tiny market movement, as well as 50ms and 200ms channels and even custom frequency options on demand
. Developers can choose the update interval that matches their protocol’s needs – from sub-millisecond streaming for high-frequency trading bots, to, say, 100ms or 200ms throttle if they only need prices synced with block times. This ability to configure update frequency (or even dynamically adjust it) gives protocols fine-grained control over the latency vs. cost trade-off.
On-Chain Efficiency: Lazer is engineered to be highly efficient in on-chain computation and bandwidth. Its lightweight 100-byte price proofs and simple verification logic mean consuming a Lazer feed uses minimal resources in environments like EVM or Solana
. For example, on Solana a single transaction can pull 20 real-time price updates at once using only ~15k compute units – an extremely low cost for that volume of data
. This efficiency ensures that even high-frequency updates remain affordable, allowing protocols to integrate fast data without breaking the bank on gas or hitting throughput bottlenecks. (In other words, Lazer’s design “does more with less,” which is crucial when updating prices every few milliseconds.)
Comprehensive Market Data: Beyond just the latest price, Pyth Lazer provides a rich set of market insights akin to what centralized exchanges offer
. Lazer feeds include the top-of-book bid and ask prices, giving insight into the current spread, and can include market depth information (how much liquidity is available at various price levels). Additionally, the Pyth team plans to introduce custom data views like moving averages and other analytics on Lazer feeds
. This comprehensive data is invaluable for traders and protocols – for instance, a DeFi application can use bid/ask data to more accurately gauge slippage or to decide whether a price move is driven by genuine buying/selling pressure. By delivering such detailed market context, Lazer empowers on-chain applications to make decisions with a fullness of information that was previously hard to obtain without CeFi APIs.
Customizable Channels & Visualization: Pyth Lazer’s architecture is flexible. Developers can tailor the feed frequency and even throttle updates to align with their application’s logic or the underlying chain’s block time
. For example, a protocol might use a continuous 1ms feed for internal risk modeling, but only act on it every 50ms to match its state update cycle. Lazer supports such throttling and scheduling, ensuring that speed is delivered on the protocol’s terms. Moreover, all Lazer data is recorded and accessible for historical analysis, and Pyth provides integration with tools like TradingView for visualization
. This means developers and end-users can easily chart the high-frequency price action or analyze how an algorithm might respond, using familiar visualization platforms. The combination of real-time streaming with historical data access makes it easier to both use and monitor the firehose of information Lazer provides.
Data Selection & Scalability: The Lazer system is built to scale with the growing market. It can support 1,000+ distinct price feeds across various asset classes
, ensuring that if your protocol needs data on a wide range of markets (crypto, equities, FX, etc.), Lazer can likely supply it. The architecture is flexible to add new assets or markets as demand arises, so emerging assets can be included. In essence, scalability is a first-class feature – Lazer isn’t just a one-off feed for a single pair, but a broad suite of high-speed feeds that can expand to cover whatever the DeFi community needs next
pyth.network
. This is important for protocols that may want to quickly roll out support for new trading pairs or instruments; they can rely on Lazer to have the necessary data ready in real-time.
Multi-Chain Support: Like Pyth Core, Pyth Lazer is designed to be blockchain-agnostic in terms of where its data can be consumed. It supports all major blockchain environments, including EVM-compatible chains (Ethereum and L2s, BSC, Polygon, etc.), the Solana ecosystem, and others
pyth.network
. The integration process ensures that whether a protocol is built on an Ethereum-based chain, Solana, Aptos/Move, Cosmos, or even off-chain environments, they can receive the Lazer feeds. This cross-chain reach is crucial: many advanced trading platforms are exploring high-performance chains (like specialized L1s or rollups), and Pyth Lazer aims to meet them where they are. The seamless integration across ecosystems means Lazer’s ultra-fast data can become a universal resource for Web3 developers, rather than being tied to a single chain
.
In summary, Pyth Lazer’s feature set is all about speed, efficiency, and richer data, delivered in a flexible way. It was created to push the envelope of what on-chain oracles can do, by providing a service that approaches the performance of traditional finance data streams while maintaining the trust principles of blockchain (albeit with some compromises on permissionlessness).
Integration & Access Model
Unlike Pyth Core (whose feeds are openly available to any project), Pyth Lazer requires a special integration process due to its permissioned nature. To start using Pyth Lazer, a protocol typically will need to coordinate with the Pyth Network team or the data association to get access to the Lazer stream on their desired chain. The launch of Lazer was accompanied by governance proposals in the Pyth DAO to set up this framework – for instance, deploying new verifier contracts and designating who can publish Lazer prices
. Initially, Douro Labs (the team behind Pyth) was assigned as the trusted signer for Pyth Lazer, meaning the Lazer data is produced and signed by a specific authority rather than through the usual decentralized consensus of many data providers

. This setup allows Lazer to achieve its millisecond latency (since it bypasses multi-party aggregation delays), but it also means access is controlled – only those with permission can receive and use the signed prices from that trusted source. In practice, a project that wants to integrate Pyth Lazer would likely go through a few steps:
Reach out and Onboard: They express interest to the Pyth team (or community) to become a Lazer data consumer. Given Lazer’s focus, likely candidates are exchanges, high-frequency trading protocols, or other latency-critical services.
Custom Integration Setup: The Pyth contributors will provide the necessary technical setup – e.g. endpoints or library support to fetch the Lazer feed, and the public key(s) to verify Lazer's signatures on-chain. The integration is custom in the sense that it may be tailored to the protocol’s environment (Solana programs, EVM contracts, etc.) and the specific channels (which assets and what frequency) the protocol needs
.
Testing and Deployment: Because this is cutting-edge tech, a period of testing would ensure the protocol can handle the high-frequency updates and that the oracle data meets their needs. Once ready, the protocol can start pulling Lazer updates in production.
An example of this process in action is Coinbase International Exchange, which became one of the first adopters of Pyth Lazer in Q1 2025
. Coinbase integrated Lazer to power its exchange’s real-time pricing needs, thereby obtaining millisecond-level price updates on-chain to support their trading operations
. This was a significant validation of Lazer’s value: a major exchange leveraging a decentralized oracle service for better speed. According to Pyth Network, Coinbase’s use of Lazer provided “precise, real-time price feeds for unmatched accuracy and responsiveness,” demonstrating institutional interest in on-chain data that rivals traditional data feeds
. It’s worth noting that because Pyth Lazer is currently permissioned, the set of data consumers is kept small and targeted. This helps ensure that the quality of service (latency and throughput) remains very high for those users. Over time, if the system proves stable and scalable, the Pyth community might consider opening access more broadly or decentralizing the data publishing process. For now, Pyth Lazer’s model is a bit like a specialized club: if you have a use case that truly needs it (and presumably the willingness to pay for the data and possibly meet any requirements set by Pyth governance), you can join and get a direct firehose to real-time market data. From a developer’s perspective, integrating Lazer would involve using the provided API or on-chain contract interface to request price updates similarly to Pyth Core (e.g., calling an update function with the signed price data). The difference is that the data will come from the Lazer feed (with its own verifier contract) rather than the public Pythnet feed. The fee for each update call still applies, as with Pyth Core, but thanks to Lazer’s efficiency, the gas or compute cost of handling the update is lower. The end result is that once integrated, a protocol can fetch prices on-demand just as they would with Pyth Core – except now the data can be updated every few milliseconds if needed.
Use Cases and Benefits of Pyth Lazer
Pyth Lazer unlocks a variety of high-value use cases in both decentralized and centralized trading contexts, thanks to its ultra-low latency and rich data. Here are some of the main applications and benefits:
High-Frequency Trading (HFT) and Algorithmic Strategies: Any on-chain protocol attempting to implement HFT-like strategies (such as arbitrage bots, rapid rebalancers, or very short-term traders) can benefit enormously from Lazer’s 1ms updates. In traditional finance, proprietary trading firms spend millions to shave off milliseconds – Pyth Lazer brings that level of speed onto blockchain rails. For example, a perpetual futures exchange built on a fast L1 could use Lazer to update funding rates or index prices every few milliseconds, ensuring that its pricing stays synchronized with global markets in real time. This can make on-chain perpetual swaps just as responsive as those on centralized exchanges, eliminating the usual lag that traders might exploit. In fact, Pyth contributors noted that Lazer’s introduction enables a “whole new set of applications and use cases” that were not feasible before, precisely because now on-chain programs can get data as fast as needed
pyth.network
.
Mitigating Oracle Latency Arbitrage and Front-Running: One of the risks in DeFi has been oracle front-running – when an attacker, seeing a price update about to occur (or a slight difference between on-chain price and off-chain real price), quickly trades against a protocol before it can adjust. With traditional oracles that update only every few seconds (or slower), this leaves a large window for exploitation. Pyth Lazer essentially shrinks the update interval to near-zero, which can eliminate the opportunity for many of these exploits
. If prices are updating every millisecond, a would-be attacker on a blockchain mempool has virtually no time to act on stale information, because by the time their transaction executes, the price feed is likely updated. Thus, latency-sensitive protocols (like decentralized exchanges and lending platforms during volatile swings) can significantly reduce slippage and protect users from bad trades triggered by outdated prices
. Lazer’s speed, combined with Pyth’s existing features like confidence intervals, creates a much safer environment where market moves are reflected on-chain almost immediately, leaving little room for predatory strategies that rely on being faster than the oracle.
CeFi-to-DeFi Bridging: As seen with Coinbase’s integration, Pyth Lazer is not just for DeFi protocols – it also appeals to centralized exchanges (CeFi) and other institutional players looking to tap into on-chain data. By using Lazer, a centralized exchange could, for instance, publish their internal price index on-chain in real time or hedge on DeFi platforms with instantaneous oracle updates. Similarly, market makers and trading firms (like Wintermute, which publicly supported Lazer) can use the feed to inform their on-chain trading algorithms across 80+ blockchains where Pyth is live
. The ability to get millisecond data on a decentralized network means traditional finance participants can start to integrate their systems with on-chain markets more seamlessly. Pyth Lazer essentially acts as a bridge between TradFi and DeFi speeds, encouraging more liquidity and activity to flow on-chain because the data delay is no longer a barrier.
Advanced DeFi Derivatives and Exotic Products: With richer data like order book depth and moving averages coming from Lazer, DeFi developers can create more sophisticated financial products. For example, an options protocol might use real-time implied volatility indices derived from Lazer’s high-frequency feeds. Or a lending protocol could use Lazer’s bid/ask info to dynamically adjust collateral requirements (since a wide bid-ask spread might indicate market stress, which could be responded to faster). Structured products that require underlying price sampling (like certain decentralized volatility derivatives or turbocharged vaults) could sample the price every few milliseconds via Lazer to compute payoffs more accurately at expiry. Essentially, any use case that was held back by oracle refresh rates or data limitations can be re-imagined with Pyth Lazer’s capabilities, making on-chain markets more competitive with their off-chain counterparts.
Improved User Experience in DeFi: Even for more traditional DeFi apps (like DEXs or aggregators), having access to fast and granular data can improve user experience. For instance, a DEX UI could display a near real-time price chart powered by Pyth Lazer, so users see live prices (with bids/asks) updating every millisecond while they prepare a trade – something typically only seen on centralized exchange interfaces. This can build user trust that the on-chain price is “current” and not 5-10 seconds old. Additionally, faster oracles can enable features like real-time stop-loss or take-profit orders on decentralized platforms; a contract could continually evaluate a position against a Lazer feed and trigger an action at precisely the desired price point without waiting for the next block. Thus, Lazer not only helps with the backend performance but can translate to front-end responsiveness and features that make DeFi feel as smooth as TradFi.
In summary, Pyth Lazer’s ultra-low latency and data richness benefit any scenario where timing and information detail are critical. It allows on-chain protocols to operate on a much shorter feedback loop. By doing so, it addresses one of DeFi’s historical disadvantages (slower data) and opens the door to new innovations that were previously impractical. As one industry expert put it, “Latency continues to be the primary barrier preventing institutional-grade finance from thriving on-chain… By delivering price updates at 1ms frequencies, a whole new set of applications becomes possible.”
. Pyth Lazer is the tool that can make those applications a reality.
Using Pyth Lazer as a Secondary Oracle Feed
One particularly interesting approach for leveraging Pyth Lazer is to use it in tandem with existing oracle feeds to combine the benefits of both. Because Pyth Lazer is extremely fast but somewhat more centralized, while Pyth Core (or other oracles like Chainlink) are slower but highly decentralized, a protocol can design a hybrid strategy to optimize cost, speed, and security. In practice, this could mean using Pyth Lazer as a secondary (confirmation) oracle feed alongside a primary feed for important transactions. There are a couple of ways this dual-oracle strategy can play out:
Real-Time Monitoring with On-Demand Primary Updates: In this pattern, a protocol would rely on an economical primary oracle (e.g., Pyth Core updating every 400ms, or another feed updating every minute) for its official on-chain price data, but continuously monitor the market via Pyth Lazer off-chain. Because Lazer can stream prices every millisecond, the protocol (or its keepers) can set up alerts for significant price movements. If Lazer shows that the price is changing rapidly or has crossed a certain threshold, the protocol can then trigger an on-chain update from the primary oracle immediately. Conversely, if the market is stable, the protocol might skip unnecessary on-chain oracle calls for a while. This way, Lazer acts as a fast filter or early warning system, and the primary oracle is pulled only when needed. The result is cost savings – fewer on-chain calls (which cost gas or fees) when markets are calm – without sacrificing the ability to react quickly when markets are volatile. Essentially, Lazer’s rapid feed helps ensure you “pay only for what you need” from the slower oracle, aligning with Pyth’s pull oracle philosophy

.
Cross-Verification for Safety: Another use is to improve the robustness of price data by checking one oracle against another. A protocol could design its logic such that it requires two sources to agree (within some tolerance) before acting on a price. For example, imagine a lending platform that primarily uses a well-known oracle (say Chainlink) for prices. They could subscribe to Pyth Lazer for the same asset and whenever a price update comes from Chainlink, quickly compare it with Lazer’s latest reading. If the two are consistent (and Lazer hasn’t detected any sudden swing that Chainlink missed due to update delay), the protocol proceeds normally. If there’s a discrepancy (say, Chainlink’s price is significantly different from Lazer’s current price), that could be a signal to pause or apply protective measures (because maybe Chainlink’s data is momentarily stale or an attack is in progress). In this scenario, Pyth Lazer serves as a real-time “sanity check” for the primary oracle. Since Lazer’s cost is mainly incurred when you actively pull it on-chain, the protocol could optimize by only pulling Lazer on-chain when such discrepancies arise, or use a light off-chain server to monitor Lazer and only intervene on-chain when needed. This can enhance security without continuously doubling the cost. It’s like having a second opinion for critical decisions: mostly you don’t need to ask, but when something looks off, you consult the faster oracle for confirmation.
Notably, the Pyth team itself encourages cross-referencing Pyth Lazer with Pyth Core to add resilience to applications
. By combining Lazer’s high-frequency performance with a decentralized baseline source, developers get the best of both worlds: speed and reliability. In practice, implementing a dual oracle setup requires careful design (to avoid inconsistent states or complexity), but when done right, it can both save money and reduce risk. You save costs because you aren’t pulling heavy on-chain updates at the highest frequency 100% of the time – you let Lazer’s off-chain or low-cost feed tell you when it’s truly necessary. And you improve safety because any single oracle’s failures or delays can be caught by the other. For many DeFi projects, especially those dealing with sensitive financial contracts, this kind of setup could be a prudent way to use Pyth Lazer: not necessarily as the sole source of truth, but as a powerful auxiliary tool that ensures they never miss a beat of the market.

Pyth Lazer represents a significant leap forward in oracle technology, bringing DeFi into the realm of real-time data. By offering millisecond-level price updates and an abundance of market information, it addresses one of the key limitations that decentralized applications have faced when competing with centralized platforms. Speed is now a feature that DeFi protocols can harness, thanks to Lazer’s design. While it does so by cleverly relaxing some decentralization, Pyth Lazer maintains the ethos of the Pyth Network: leveraging first-party institutional data and delivering it on-chain in a secure manner
pyth.network
. For developers and traders, this means new possibilities – markets that update in the blink of an eye, smart contracts that can execute with minimal latency, and a blending of on-chain/off-chain finance that was previously unattainable. It’s important to recognize that Pyth Lazer is complementary to Pyth Core, not a wholesale replacement. For many use cases, the regular Pyth feeds (and other decentralized oracles) remain more than sufficient and offer maximal trust and openness. But for those edge cases and emerging applications where performance is king, Pyth Lazer provides a specialized solution that says: you don’t have to settle for “block time” speed anymore. As the crypto industry moves forward, we may well see Pyth Lazer (and similar low-latency oracles) powering the next generation of on-chain exchanges, games, and financial instruments – the kinds that we haven’t even imagined yet, but now can be built because the data backbone is fast enough to support them. In summary, Pyth Lazer is a game-changer for on-chain data infrastructure. It gives developers a new option in their toolkit: an oracle feed that moves at the speed of traditional finance, with the customizability and composability of blockchain. Whether used alone or in tandem with other feeds, Lazer can help protocols save costs, reduce risks, and most importantly, stay ahead of the market in real time. With initiatives like Pyth Lazer, the gap between DeFi and TradFi continues to narrow, heralding an era where decentralized applications can truly match the performance of their centralized counterparts
. The future of finance may well be one where every millisecond is accounted for on-chain – and Pyth Lazer is a strong step in that direction. Sources:
Pyth Network Blog – Introducing Pyth Lazer: Launching DeFi Into Real-Time (Jan 2025)

Messari Research – State of Pyth Q1 2025 (Analysis of Pyth Network’s developments, including Pyth Lazer)

LinkedIn Post – Keyvan Khademi, “DeFi Has a New Benchmark for Speed: Introducing Pyth Lazer” (Highlights of Lazer’s specs)

Pyth Network Blog – Pyth Benchmarks: Historical Price Data On Demand (mentions Pyth Core 400ms update frequency)

Pyth Network Blog – Pyth Primer: Confidence Intervals (explains Pyth Core’s price + confidence interval approach)

Official Pyth Network Website – “Launch your app with a permissionless Pyth integration” (notes on open integration for Pyth Core)

Pyth Network on X (Twitter) – Announcement of Pyth Lazer (feature summary: 1ms, 15k CU, 100-byte proofs, etc.)
