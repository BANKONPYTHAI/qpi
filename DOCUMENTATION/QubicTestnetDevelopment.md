Qubic Testnet Development Environment Setup and Smart Contract Deployment Guide
Required Tools and Setup
To build and deploy Qubic smart contracts, you will need a Qubic Node, the Qubic CLI, and relevant SDKs or libraries. The Qubic Node is the core software that runs the blockchain – a full node implementation that includes smart contract execution and the Qubic Programming Interface (QPI) for writing contractsdocs.qubic.org. The Qubic CLI (Command Line Interface) is an essential tool for developers to communicate with Qubic nodes, enabling operations like checking balances, sending transactions, and invoking smart contract functionsdocs.qubic.org. Qubic provides a Dev Kit which streamlines setting up a local testnet node and includes example smart contract code. This Dev Kit is optimized for a specific testnet branch and can simulate the entire Qubic blockchain in one environmentdocs.qubic.orggithub.com. Additionally, Qubic offers SDKs such as an official TypeScript library to interact with the network programmatically, and a community-driven Java Shell client (a Java-based CLI and wallet) for node communicationdocs.qubic.org. Together, these tools form the foundation of your local Qubic development environment.

Before proceeding, ensure you have a suitable development machine (Linux is recommended) and required dependencies. The Qubic Dev Kit repository provides an automated setup. In summary, you will need to clone the Dev Kit and run its environment setup script, which will install dependencies and fetch all necessary components (including the Qubic core code, CLI, and any docker or VM images)github.com. After that, you will compile or download the Qubic node software (provided as an EFI binary in the Dev Kit) and prepare a virtual disk with the test blockchain state. This one-time setup prepares your local environment for running a Qubic test network node.

Running a Local Qubic Testnet Node
With the environment prepared, you can now launch a local Qubic testnet node. The Qubic Dev Kit simplifies this with a single deployment script. Step 1: Run the environment setup script (if you haven't already) – for example: sudo ./environment_setup.sh. This will install all tools and build components needed for Qubic developmentgithub.com. Step 2: Deploy the testnet node and demo contract by running the provided deploy script. For instance: ./deploy.sh /root/qubic/Qubic.efi (using the pre-compiled Qubic node EFI provided by the Dev Kit)github.com. This command performs several tasks automatically: it configures a virtual blockchain disk (e.g., loading a snapshot at a given epoch)github.com, launches the Qubic node in a virtualized environment, and starts the RPC services (the HTTP API endpoints for interacting with the node). The Dev Kit will also launch a demo frontend application in your browser for convenience, but this is optional. Once the deploy script completes, you have a single-node Qubic testnet running locally, which generates new ticks (analogous to blocks) and is ready to accept transactions and smart contract interactions.

Under the hood, the Qubic node is running the Hackathon Madrid 2025 (HM25) demo smart contract by default. This is a template contract provided by Qubic for development and testingdocs.qubic.orggithub.com. The HM25 smart contract includes simple example functionality: an Echo procedure that returns sent funds back to the caller, a Burn procedure that destroys (burns) the sent funds, and a GetStats function to retrieve usage statistics (such as how many times Echo or Burn have been called)github.com. Having this contract running on your local node confirms that your testnet is operational. The node will continuously tick (produce new time slots for contract execution), and the smart contract’s state is kept in sync across ticks. You can now interact with this contract or deploy your own by modifying the setup.

Deploying your own smart contract: Qubic smart contracts are written in C++ using the QPI (Qubic Programming Interface). To deploy a custom contract on the testnet, you will modify the Qubic core source and include your contract code, then compile a new Qubic node binary (EFI). The Dev Kit is optimized for the provided demo contract, but it notes that for a custom contract you should start from the main Qubic core repository and add your contract theregithub.com. Typically, you would create or edit a contract file in src/contracts/ and register its functions/procedures in the code. For example, the HM25 demo contract is defined in a file HM25.h and its user-facing procedures are registered using a macro REGISTER_USER_PROCEDURE (which assigns each procedure a type ID)github.com. After writing your contract logic (ensuring you follow QPI rules like pre-allocating all memory and using QPI types), you compile the Qubic core to produce a new Qubic.efi containing your contract. You can then rerun the deployment script pointing to your custom EFI to launch a node with your smart contract deployed. In a local single-node testnet, this effectively deploys the contract because the node is now running your code. (On the real Qubic network, contract deployment is a governed process requiring approval by the network’s Computors, but on a testnet node you control, you can add contracts freelygithub.comgithub.com.)

Obtaining Qubic Testnet Tokens
Once your local Qubic testnet node is running, you will need test tokens (QU on testnet) to deploy and interact with contracts. Qubic operates with feeless transactions, but tokens are still required to fund contract calls (for example, to provide an invocation reward or to transfer value into a contract)medium.comdocs.qubic.org. The Qubic team provides several ways to get testnet tokens:

Discord Faucet: Join the official Qubic Discord server and navigate to the #bot-commands channel. Qubic’s faucet bot can dispense free tokens. Using the faucet command in Discord will grant you some Qubic tokens for testing (e.g. “!faucet” command – the bot will send 1000 Qubic on mainnet or an equivalent amount of testnet tokens)github.com. This is useful if you are interacting with an official testnet or if your local node is configured to use the same testnet parameters.

Pre-Funded Test Seeds: For the isolated local testnet node (such as the one launched via the Dev Kit), the environment often comes pre-configured with certain seed phrases that already control accounts loaded with test tokens. In the HM25 Dev Kit and hackathon setup, for example, a list of test seeds was provided, each pre-funded with 1 billion test Qubic tokensgithub.comgithub.com. You can use any of these seed phrases to derive a private key and identity that has tokens on the testnet. Since your local node is running a deterministic environment, these seeds ensure you start with plentiful funds for development.

Using the Seeds: To utilize a seed phrase in Qubic CLI, you can pass it as a parameter. For instance, the CLI allows a -seed <YOUR_SEED> argument which will derive the corresponding keypair and sign transactions with itdocs.qubic.orggithub.com. The test seeds given in documentation can be used directly with CLI or wallet tools to access the pre-funded accounts. There is no separate “faucet” needed in a single-node local testnet since you already have funds available via these accounts.

In summary, if you’re on the official testnet (if one is publicly available), use the Discord faucet to request tokens to your test address. If you’re using the Dev Kit’s local node, simply pick one of the provided test seeds (or use the default seed configured in the demo) to access the pre-funded test tokens.

Deploying and Interacting with Smart Contracts on Testnet
With a running node and available test tokens, you can now deploy (activate) and interact with smart contracts on the Qubic testnet. In a local environment, “deploying” a contract means starting your node with the contract included (as described earlier). On a multi-node public testnet, deployment would involve submitting your contract code for inclusion (which on Qubic mainnet requires a quorum approval processgithub.com, though on a testnet this may be more permissive). Assuming your contract is running on the node, the next steps are to interact with it and verify its behavior.

Using Qubic CLI: The CLI is the primary tool to send transactions and invoke contract functions. First, ensure your CLI is configured to talk to your testnet node’s address. By default, Qubic CLI connects to a node via IP and port – for example: ./qubic-cli -nodeip <NODE_IP> -nodeport 21841 -help. (Port 21841 is the default Qubic node portdocs.qubic.org.) If you are running the node locally, NODE_IP might be 127.0.0.1 (or the Docker/VM’s IP). The CLI can perform basic account operations such as checking an identity’s balance with -getbalance <IDENTITY> and sending tokens with -sendtoaddress <TARGET_IDENTITY> <AMOUNT>docs.qubic.org. You’ll typically provide your seed so the CLI can sign these transactions (e.g., include -seed "your test seed phrase" in the command).

To call a smart contract, Qubic provides specialized CLI commands. Each contract is identified by a contract index or address, and each callable procedure/function in the contract has an index (as registered in the code). For example, in the HM25 demo, the Echo procedure was registered with index 1 and Burn with index 2github.com. The CLI offers a -callcontract <CONTRACT_INDEX> <FUNCTION_INDEX> <AMOUNT> command that constructs and sends a transaction invoking a contract’s proceduredocs.qubic.org. For instance, if the HM25 contract is at index 1 on your testnet, you could run: ./qubic-cli -nodeip ... -seed "...seed..." -callcontract 1 1 500 to call the Echo procedure with 500 QU. This would send 500 test tokens to the contract and, if using Echo, the contract will immediately return them to the sender (since Echo refunds the amount). Calling the Burn procedure (index 2) would permanently remove the sent tokens, which you could confirm by seeing the balance decrease and the contract’s internal burn count increase.

You can also call read-only functions via CLI or RPC. For example, the HM25 contract’s GetStats function (index 1 for functions) returns the number of Echo and Burn calls so fargithub.com. Using CLI to query a function may involve a different flag or the RPC interface (since functions do not require a transaction). If the CLI does not have a direct flag, you can use the RPC endpoint /v1/querySmartContract to call a function and get a responsedocs.qubic.org. In general, when using CLI, if a function call needs no payment, it might be done as -callcontract with amount 0, or via a separate query command. Check the CLI help (-help) to see the exact usage for function queries in your CLI version.

Using RPC and SDKs: In addition to the CLI, Qubic’s RPC API is available for programmatic interaction. The Dev Kit launch script starts the Qubic RPC server (qubic-http and related services) which exposes RESTful endpoints. There are public endpoints for mainnet and testnet (e.g., https://rpc.qubic.org for mainnet and https://testnet-rpc.qubic.org for the test networkdocs.qubic.org) if you are using an official testnet. You can use these endpoints to fetch chain information, submit transactions, and call smart contracts without running a full nodedocs.qubic.org. For example, a read-only call (function call) is done by POSTing to /v1/querySmartContract with the contract index and any input data, which returns the function’s output (encoded in base64)docs.qubic.org. A state-changing call (procedure) is done by creating a transaction and broadcasting it via /v1/broadcast-transactiondocs.qubic.org. The Qubic TypeScript SDK can simplify these tasks: it provides high-level methods to create and sign transactions, as well as to query balances and contract stategithub.comgithub.com. For instance, using the TS library you can generate a new identity from a seed, connect to a node (by specifying its RPC URL), check your balance with getBalance(), and even build transactions for contract calls. The TypeScript library is available as @qubic-lib/qubic-ts-library on npm and yarngithub.com. This SDK is very useful for writing front-end or integration code. (There is also a Qubic Java library if you prefer Java/Kotlin, used by the Qubic Java Shelldocs.qubic.org, but most DApp developers will find the TypeScript library and RPC easier to work with.)

Wallets for managing accounts: For managing keys and signing transactions, Qubic supports several options. The official Qubic Web Wallet (accessible at wallet.qubic.org) can be used on mainnet to create addresses, view balances, and send transactions via a user-friendly interface. For testnet development, developers often use MetaMask Snap integration or direct seed phrases. Qubic has a MetaMask Snap (Qubic Connect Snap) that allows MetaMask to understand Qubic addresses and sign Qubic transactionssnaps.metamask.io. Using this, you could connect MetaMask to a Qubic DApp (for example, the hackathon front-end demo integrated MetaMask Snap and WalletConnect to interact with the HM25 contractgithub.com). This is advanced, but it means you can use familiar wallet interfaces during development. Alternatively, you can stick with the CLI or the Qubic Java Shell for signing using your seed. In any case, ensure whichever wallet or method you use is pointed at your testnet node (for instance, by using the testnet RPC URL or your node’s IP).

Verifying Contract Deployment and State
After deploying a smart contract to the Qubic testnet (whether on your local node or an official test network), it’s important to verify that the contract is active and functioning as expected. There are a few ways to do this:

Via CLI Queries and Logs: The simplest way is to use the CLI to query contract state or trigger its functions and observe the outcomes. For example, after calling the Echo or Burn procedures, you can check the balances: the caller’s balance should increase back on Echo (refund) or decrease on Burn. You can also call a read function like GetStats (which does not cost tokens) to retrieve the internal counters for how many calls have occurred. If the CLI provides a direct command for this, use it; otherwise, you might send a special query transaction or use the RPC query as mentioned. Additionally, your node’s console output or logs can be informative – when the contract procedures execute, the node may log events or errors. If your contract failed to deploy (e.g., a code issue), the node might crash or throw an error during startup, which you’d see in the logs.

Via RPC/API: Using the RPC interface, you can programmatically verify contract state. For instance, use the querySmartContract RPC call to execute a function and inspect the returned datadocs.qubic.org. If your contract has a getter for some state variable, calling that should return a meaningful value, confirming the contract’s state is being maintained. You can also fetch transaction info via RPC (/v1/txinfo or similar) if you know the transaction ID of a contract invocation, to ensure it was included and processed.

Block Explorer: As of now, Qubic’s official explorer (explorer.qubic.org) is primarily for the mainnet. A dedicated testnet explorer is not publicly available – the development testnet is meant for internal testing and is not indexed on the main explorergithub.com. Therefore, you likely won’t find your test contract on the public explorer. If you are using an official test network and it provides an explorer or block viewer, use that to look up your contract’s address or the transactions you sent. In absence of an explorer, rely on the CLI/RPC methods above. (For advanced users, Qubic’s explorer is open-sourcegithub.com, so one could potentially run a local instance pointing to the testnet, but this is optional and beyond the scope of most developers’ needs.)

In summary, verifying a contract deployment on Qubic testnet involves ensuring your node is running with the new contract (no errors on startup), and using tools like the CLI or RPC queries to interact with the contract’s functions. For example, you might call a function that returns a known value or default state to confirm it’s correct, or invoke a procedure and then query the state change. The successful responses or state changes act as proof that your smart contract is deployed and working. On a multi-node testnet, you would also want to verify that all nodes have accepted the new contract (if the contract requires consensus approval, as on mainnet, this would be an extra step – but on a private testnet node, this isn’t an issue).

Available Explorers, Wallets, and APIs
To support your development and testing, here’s a summary of helpful tools in the Qubic ecosystem:

Blockchain Explorer: The official Qubic Explorer (explorer.qubic.org) allows you to search transactions, addresses, and contract details on mainnet. It shows live data like prices, market cap, and active addresses for Qubicexplorer.qubic.org. Currently, only mainnet is supported on this explorer; testnet data is not integrated into itgithub.com. If you deploy contracts on mainnet in the future, they would be visible here once approved and activated. During testnet development, you will rely more on direct queries as described. There is no separate public testnet explorer at this time.

Wallets: The Qubic Web Wallet (wallet.qubic.org) is an official wallet for managing QUBIC tokens and identities. It’s user-friendly for sending transactions and viewing balances on mainnet. For testnet, developers can use command-line wallets (like the Qubic CLI with seed phrases) or leverage the MetaMask Snap for Qubicsnaps.metamask.io. The MetaMask Snap integration essentially turns MetaMask into a Qubic-compatible wallet, enabling features like Qubic address generation and transaction signing within MetaMask’s interface. This is especially useful for testing DApps with a familiar wallet UX. Additionally, Qubic supports WalletConnect, so you can use mobile wallets or other WalletConnect-compatible wallets to interact with Qubic DApps (the hackathon demo showcased WalletConnect support for the Qubic HM25 dAppgithub.com). Lastly, the Qubic Java Shell is available as a more technical wallet/CLI hybrid, which you can run in a terminal; it’s part of the Qubic Java library and can perform wallet operations and node queries via text commandsdocs.qubic.org.

APIs and SDKs: Qubic’s RPC API is a key resource. As noted, the base URLs are rpc.qubic.org for mainnet and testnet-rpc.qubic.org for testnetdocs.qubic.org. The RPC provides endpoints under /v1/ for actions like checking node status (/v1/status), querying contract state (/v1/querySmartContract), broadcasting transactions (/v1/broadcast-transaction), fetching balances (/v1/balance/<identity>), and more. The Qubic documentation provides a live reference for these endpoints (called the Qubic Live Tree and Archive Tree)docs.qubic.org. For easier integration, the Qubic TypeScript SDK can be used. This library wraps the RPC calls and handles data encoding/decoding. For example, with the SDK you can create an instance of a Qubic connector to a given RPC URL, then call getBalance() or construct a transaction object to call a contract, and finally use broadcastTransaction() to send itgithub.comdocs.qubic.org. It abstracts the need to manually base64-encode request data or decode responses, making development smoother. To install the SDK, use yarn add @qubic-lib/qubic-ts-library or npm install @qubic-lib/qubic-ts-librarygithub.com. There are also example scripts in the SDK’s documentation demonstrating common tasks (creating identities, sending transactions, querying contract state)github.com. Aside from TypeScript, you could also interact via cURL or Postman by hitting the RPC endpoints directly (for instance, a cURL POST to the testnet RPC’s /v1/querySmartContract with JSON data will invoke a contract function)docs.qubic.org.

In conclusion, the Qubic blockchain provides a comprehensive environment for developers: you set up a local node or connect to a testnet node, obtain test tokens via faucet or pre-funded accounts, deploy your smart contract code to the node, and use tools like Qubic CLI, RPC APIs, or SDK libraries to interact with and verify your smart contract. While the deployment process differs from Ethereum-style “one-click” contract creation (since Qubic contracts run as part of node software), the provided Dev Kit and documentation make the process manageable. By following the steps above – setting up the dev environment, using the CLI/Dev Kit to deploy a testnet node with your contract, funding your test accounts, and interacting via CLI or SDK – you can develop and test smart contracts on Qubic’s high-performance, feeless blockchain. Once satisfied, you can then consider deploying to the Qubic mainnet, which involves an approval (IPO) process with the community of Computor nodesgithub.com. For now, enjoy building on the Qubic testnet and exploring its unique approach to smart contracts! Good luck, and happy coding with Qubic.

Sources:

Qubic Documentation – CLI and Node Overviewdocs.qubic.orgdocs.qubic.org

Qubic Dev Kit Guide – Local Testnet Setupgithub.comgithub.com

Qubic Hackathon Resources – Faucet and Test Seedsgithub.comgithub.com

Qubic CLI Usage – Account and Contract Commandsdocs.qubic.orgdocs.qubic.org

Qubic Hackathon Demo – HM25 Contract Functions (Echo/Burn)github.com

Qubic RPC API Reference – Endpoints and Usagedocs.qubic.orgdocs.qubic.org

Qubic TypeScript SDK – Installation and Examplesgithub.comgithub.com

Qubic MetaMask Snap & WalletConnect – Integration detailssnaps.metamask.iogithub.com

Qubic Explorer/Network Info – Mainnet vs Testnet availabilitygithub.com
